'''
A simple bot that:
	- Accepts commands when given to it with "Botslices, <command>"
	- Watches for people joining a server and records what invite they used
	- Watches for people leaving a server
	- Responds to messages with reactions and text
	- Pongs when pinged

Todo:
	- GPT 3.5 Turbo integration
	- blacklist
		-"Botslices, ignore user"
		-"you got it"
		-add name to file, then read file in to memory as a black list
	- find better solution to cross-server emojis
	- Set up logging
		- process output
		- log cleanup
	- Use regex to parse messages
	- Do something for Darktide
	- 

'''

import discord
from discord.ext import commands
from discord.utils import get
import re
import random

DEBUG = 0

with open('/home/liverslices/discord/my-first-bot/token.tok') as f:
	token = f.read()

# Dict of dicts. Top level is guild ID as key, dict of info as value
servers = {
	1133909806802030733: {
		"guildName": "Reginald's Redemptionists",
		"inviteTrackingChannelId": 1140989119321878629
	},
	675899094740500496: {
		"guildName": "The Reckoner Zone",
		"inviteTrackingChannelId": 675899094740500507
	},
	1241134342890061924: {
		"guildName": "Talking to myself",
		"inviteTrackingChannelId": 1241134343343312918
	}
}

bot = commands.Bot(command_prefix=("+"), intents=discord.Intents.all())

invites = {}
guildEmojis = {}

def find_invite_by_code(invite_list, code):
	for i in invite_list:
		if i.code ==  code:
			return i
@bot.event
async def on_ready():
	# get list of guilds this bot is a member of
	for g in bot.guilds:
		# get a list of all invites to be checked by on_member_join()
		invites[g.id] = await g.invites()

		# get a list of all emojis to be checked by on_message()
		# guildEmojis[g.id] = {} # Disabling this to simplify guildEmojis
		for e in g.emojis:
			# guildEmojis[g.id][e.name] = e.id $ Disabling this to simplify guildEmojis
			guildEmojis[e.name] = e.id

	if DEBUG: print(invites)
	if DEBUG: print(guildEmojis)

@bot.event
async def on_member_join(member):
	# for this event I am calling the current invites[] values "previous" since they are now outdated
	if DEBUG: print(f"DEBUG: invites\n{invites}\n")
	if DEBUG: print(f"DEBUG: member\n{member}\n")

	# grab the previous invite counts that were created during on_ready()
	invites_before_join = invites[member.guild.id]
	if DEBUG: print(f"DEBUG: invites_before_join\n{invites_before_join}\n")

	# get the new invite counts from the server that this member just joined
	invites_after_join = await member.guild.invites()
	if DEBUG: print(f"DEBUG: invites_after_join\n{invites_after_join}\n")

	# for each of previous invites
	for ibj in invites_before_join:
		# if the previous count of this invite is not equal to the new invite count
		if ibj.uses != find_invite_by_code(invites_after_join, ibj.code).uses:
			if DEBUG: print(f"DEBUG: find_invite_by_code(invites_after_join, ibj.code).uses\n{find_invite_by_code(invites_after_join, ibj.code).uses}\n")
			print(f"{member.name} joined guild {member.guild.id} using invite code {ibj.code} generated by {ibj.inviter}")

			# update invite counts to what the are now
			invites[member.guild.id] = invites_after_join

			inviteTrackingChannel = bot.get_channel(servers[member.guild.id]["inviteTrackingChannelId"])
			await inviteTrackingChannel.send(f"`{member.name}` joined `{servers[member.guild.id]['guildName']}` using invite link `{ibj.code}` generated by `{ibj.inviter}`")

			return

@bot.event
async def on_member_remove(member):
	leaveTrackingChannel = bot.get_channel(servers[member.guild.id]["inviteTrackingChannelId"])
	await leaveTrackingChannel.send(f"`{member.name}` has left `{member.guild.name}`")

@bot.event
async def on_message(message):

	# Botslices
	if re.search("botslices", message.content, re.IGNORECASE):
		# you there?
		if re.search(".*you.*(there|running)\??", message.content, re.IGNORECASE):
			await message.channel.send("yup")
		# _______?
		elif re.search(".*\?", message.content):
			responseList = (
				"yup",
				"nope",
				"probably",
				"probably not",
				"maybe",
				"no chance, bud",
				"definitely",
				"definitely not"
			)
			await message.channel.send(responseList[random.randint(0,len(responseList)-1)])
		# Ping pong
		elif re.search(r"\bping\b", message.content, re.IGNORECASE):
			await message.add_reaction("üèì")
		# stfu
		elif re.search(r"\bstfu\b", message.content, re.IGNORECASE):
			await message.channel.send("~~,' , |,'_'~~")
		# Otherwise...
		else:
			await message.add_reaction("ü§ñ")

	# Bugs
	if re.search(r"\bbugs?\b", message.content, re.IGNORECASE):
		await message.add_reaction(message.guild.get_emoji(guildEmojis["Eagle_Napalm_Airstrike"]))
		# await message.channel.send("‚ñ≤‚ñ∫‚ñº‚ñº‚ñº")

	# Bots
	if re.search(r"\bbot(?!slices)s?\b", message.content, re.IGNORECASE):
		await message.add_reaction(message.guild.get_emoji(guildEmojis["Eagle_500KG_Bomb"]))
		# await message.channel.send("‚ñº‚óÄ‚ñº‚ñ≤‚ñ≤‚ñ∫")

	# Divin
	if re.search(r"diving?", message.content, re.IGNORECASE):
		await message.add_reaction(message.guild.get_emoji(guildEmojis["Reinforce"]))

	# Slop
	if re.search(r"slop", message.content, re.IGNORECASE):
		await message.add_reaction(message.guild.get_emoji(guildEmojis["slop_stare"]))

	# Smoke
	if re.search(r"smoke", message.content. re.IGNORECASE):
		await message.add_reaction(message.guild.get_emoji(guildEmojis["Orbital_Smoke_Strike"]))

	# Heretic/Heresy
	if re.search(r"here(sy|tic)", message.content, re.IGNORECASE):
		await message.add_reaction(message.guild.get_emoji(guildEmojis["Flamethrower"]))

	# Move on to commands
	await bot.process_commands(message)

@bot.command()
async def good(ctx, activity):
	match activity:
		case "gambit":
			response = "gambit sucks"
		case "strikes":
			response = "strikes are boring"
		case _:
			response = "shut up man"
	await ctx.send(response)

@bot.command()
async def whoami(ctx):
	await ctx.send("you are " + ctx.author.name)

bot.run(token)
